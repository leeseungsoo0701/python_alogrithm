"""
부분 집합 구하기

상태 트리가 뭐냐 -> 재귀를 좀 더 쉽게 이해할 수 있도록 그려보는 것

1. 부분집합이 경우 선택하는 것, 선택하지 않는 것으로 고를 수 있다.

재귀란 탈출조건이 중요한데 이 문제에서는 레벨이 4일 경우에 탈출해야한다.
또하나 중요한 점은 브랜치의 갯수 == 재귀를 호출하는 갯수
2개씩 뻗어가는 것이므로 이 문제에서는 재귀를 2번만 하면 된다.


"""
# def DFS(L,res):
#     if L == len(N):
#         print(res)
#         return
#
#     DFS(L + 1, res + [N[L]])
#     DFS(L + 1, res)
#
#
# N = [4,5,6]
# DFS(0,[])


"""
중복 순열

"""

# # 1,2,3,4를 입력 받기 위한 수 (갯수를 입력 받기 위함)
# N = int(input())
#
# # 전체 갯수 중 뽑아야할 갯수에 대한 입력
# M = int(input())
#
# # DFS 함수로 level과 결과에 해당하는 res가 받아야할 변수로 필요하다.
# # 현재 level은 M에 해당할 것이며
# # 재귀를 실행해야할 횟수 즉 간선의 갯수는 N이다.
# def DFS(L,res):
#     if L == M:
#         print(res)
#         return
#
#     for i in range(N):
#         DFS(L+1, res + str(i+1))
#
#
# DFS(0,[])


######
# N = [4,5,6,7]
#
# # 전체 갯수 중 뽑아야할 갯수에 대한 입력
# M = int(input())
#
# # DFS 함수로 level과 결과에 해당하는 res가 받아야할 변수로 필요하다.
# # 현재 level은 M에 해당할 것이며
# # 재귀를 실행해야할 횟수 즉 간선의 갯수는 N이다.
# def DFS(L,res):
#     if L == M:
#         print(res)
#         return
#
#     for i in range(len(N)):
#         if N[i] in res:
#             continue
#         else:
#             DFS(L+1, res + [N[i]])
#
#
# DFS(0,[])

############################
"""
배열과 뽑아야할 갯수를 입력 받아 조합을 배열로 나타내라
"""

N = [4,5,6,7]

# 전체 갯수 중 뽑아야할 갯수에 대한 입력
M = int(input())


####### 조합
####### 재귀함수를 사용할 때 필요한 점은 1. 언제 멈추는가 2.반복되는 일은 무엇인가 3.한 level을 더할 때 간선의 갯수는 몇개인가 이다.
def DFS(L:int ,res: list[int],idx:int)->list[int]:
    ## 재귀함수를 사용할 때, level과 뽑고자 하는 갯수가 같을 때 계속해서 더해주는 res를 프린트하며 위 함수는 종료된다.
    if L == M:
        print(res)
        return

    ## 조합에서 재귀함수를 사용할 때는 모든 간선이 필요한 것이 아닌 현재까지 더해진 res의 최댓값보다 크거나 같은 값들만 재귀함수로 보내주면 된다.
    ## 이 말은 즉슨 idx도 함께 넘겨줘야하며 입력 받은 배열을 sort 후 현재 인덱스보다 1이 커진 상태에서는 dfs 간선들을 보내면 된다
    ## 예를 들어 지금 상황은 idx == 0, N[idx] ==4 인 상황에서는 앞으로 idx == 1,2,3이 필요한 것이고(더 큰 값들만 넣어주면 되기 때문에)
    ## 한 바퀴 돌았을 때 idx == 1 , N[idx] == 5이다 그리고 넘겨주는 것은 idx = 2로 다음에 돌 때는 2,3만 for문에서 돌 것이다.
    for i in range(idx, len(N)):
        DFS(L + 1, res + [N[i]], i+1)


DFS(0,[],0)







